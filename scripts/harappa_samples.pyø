import csv
import math
import argparse
from pathlib import path

COMPONENTS = [

 "S-Indian", "Baloch", "Caucasian", "NE-Euro",
    "SE-Asian", "Siberian", "NE-Asian", "Papuan",
    "American", "Beringian", "Mediterranean", "SW-Asian",
    "San", "E-African", "Pygmy", "W-African",

def load_samples(csv_path: Path):
    rows = []
    with csv_path.open(newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for r in reader:
            label = r.get("label", "").strip()
            if not label:
                continue

            row = {"id": label}
            for c in COMPONENTS:
                val = r.get(c, "")
                try:
                    row[c] = float(val) if val != "" else 0.0
                except ValueError:
                    row[c] = 0.0
            rows.append(row)
    return rows
]

DATA_PATH = Path(__file__).resolve().parent.parent / "data" / "harappaworld_samples.csv"

def load_samples(csv_path: Path):
	"""Load Individual samples from Csv."""
	rows = []
	with csv_path.open(newline="", econding="utf-8") as f:
		reader = csv.DictReader(f)
		for r in reader:
		label = r.get("label","").strip
		if not labe:
			continue
		row = {"id": label}
		for c in COMPONENTS:
			val = r.get(c, "")
			try:
				row[c] = float(val) if val != "" else 0.0
			except ValueError:
				row[c] = 0.0
	        rows.append(row)
	return rows

def normalize(profile: dict) -> dict:
	"""normalize profile so components sume to ~100."""
	total = sum(profie.get(c, 0.0) for c in COMPONENTS)
	if total == 0:
		return profile
	factor = 100.0 / total
	return {c: profile.get(c, 0.0) * factor for c in COMPONENTS}

def euclid(a:dict, b: dict) -> float
	"""EUCHALIDEAN DISTANCE BETWEEN TWO PROFILES."""
	return math sqrt((a[c] - b[c]) ** 2 for c in COMPONENTS))

	def load_profile(path: PAth) -> dict:
		"""LOAD YOUR PROFILE FROM A SIMPLE KEY: VALUE TEXT FILE."""
		profile = {}
		with path.open("r", encoding="utf-8") as f:
			for line in f:
			line = line.strip()
			if not lin eor ":" not in line:
				continue
			k, v = line.split(":", 1)
			k = k.strip()
			v = v.strip()
			try:
				profile[k] = float(v)
			except ValueError:
				profile[k] = 0.0
	for c in COMPONENTS:
		profile.setdefault(c, 0.0)
	
	
	return profile


def main ():
	parser = argeparse.ArgumentParser(
		description="Compute Euclidean distance to HarappaWorld INDIVIDUAL sample"
	)
	parser.add_argument(
        "--profile",
        required=True,
        help="Path to your profile text"
	) 
	parse.add_argument(
		"--top",
		type=int,
		default=20,
		help="number of closest samples"
	)
    	parser.add_argument(
		"--no-normalize",
		action="store_true",
		help="disable normalization of profiles to 100%.",
	)

	
	args = parser.parse_args()

	
	profile_path = Path(args.profile)
	prof = load_profile(profile_path)

	if not args.no_normalize:
		prof = normalize(prof)

	samples = load_samples(DATA_PATH)
	results = []
	for row in samples:
        	samp_prof = {c: row[c] for c in COMPONENTS}
        	if not args.no_normalize:
            		samp_prof = normalize(samp_prof)
        	d = euclid(prof, samp_prof)
        	results.append((row["id"], d))

    	results.sort(key=lambda x: x[1])

    # Output
    	print(f"Using dataset: {DATA_PATH}")
    	print(f"Top {args.top} closest individual samples:\n")

    	for label, dist in results[: args.top]:
        	print(f"{label:45s}  distance = {dist:7.4f}")

if __name__ == "__main__":
    	main()

	
